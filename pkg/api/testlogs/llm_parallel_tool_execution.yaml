metadata:
  name: "LLM Parallel Tool Execution Flow"
  description: "A flow where an LLM node uses tools in parallel"

tools:
  get_website: &get_website
    type: function
    function:
      name: get_website
      description: "Fetch content from a website URL"
      params:
        type: object
        properties:
          url:
            type: string
            description: "The URL to fetch content from"
        required: [url]
  send_email: &send_email
    type: function
    function:
      name: send_email
      description: "Send an email with subject and body"
      params:
        type: object
        properties:
          subject:
            type: string
            description: "Email subject line"
          body:
            type: string
            description: "Email body content"
          recipient:
            type: string
            description: "Email recipient address"
        required: [subject, body, recipient]

nodes:
  create_input:
    type: transform
    params:
      script: |
        return {
          question: "Search these websites in parallel: https://httpbin.org/json and https://httpbin.org/uuid, then send email summaries to beatsbybuddha@gmail.com",
          context: "llm-parallel-tool-test"
        };
    next:
      default: llm

  llm:
    type: llm
    params:
      model: gpt-4o-mini
      api_key: "{{ .secrets.OPENAI_API_KEY }}"
      temperature: 0.3
      question: "{{ .shared.result.question }}"
      conversation_history: "{{ .shared.result.conversation_history }}"
      tools:
        - *get_website
        - *send_email
    next:
      default: tool_router

  tool_router:
    type: router
    params:
      input: "{{ .shared.result }}"
      tool_definitions:
        - *get_website
        - *send_email
    next:
      get_website: http_tool_split
      send_email: email_tool_split
      no_match: format_final_response

  http_tool_split:
    type: split
    next:
      default: http_tool

  email_tool_split:
    type: split
    next:
      default: email_tool

  http_tool:
    type: http.request
    params:
      method: "{{ .shared.result.tool_params.method | default: 'GET' }}"
      url: "{{ .shared.result.tool_params.url }}"
    next:
      success: format_tool_response
      client_error: format_error_response
      server_error: format_error_response

  email_tool:
    type: email.send
    params:
      smtp_host: "{{ .secrets.SMTP_HOST }}"
      smtp_port: 587
      username: "{{ .secrets.SMTP_USERNAME }}"
      password: "{{ .secrets.SMTP_PASSWORD }}"
      from: "{{ .secrets.SMTP_USERNAME }}"
      to: "{{ .shared.result.tool_params.recipient }}"
      subject: "{{ .shared.result.tool_params.subject }}"
      body: "{{ .shared.result.tool_params.body }}"
    next:
      default: format_tool_response

  format_tool_response:
    type: transform
    params:
      script: |
        var history = (shared.conversation_history || []).slice();
        if (history.length === 0) {
          history.push({
            role: "system",
            content: "You are an AI assistant with access to tools. Execute tools in parallel."
          });
          history.push({
            role: "user",
            content: shared.result_result.question || "Search websites and send email"
          });
        }
        var toolResult = "No content retrieved";
        if (input.raw_body) {
          var preview = String(input.raw_body).substring(0, 1000);
          toolResult = "Successfully retrieved website content (" + String(input.raw_body).length + " characters):\n\n" + preview;
        } else if (input.status === 'sent') {
          toolResult = "Email sent successfully to " + input.to;
        }
        history.push({
          role: "assistant",
          content: null,
          tool_calls: shared.llm_result.tool_calls
        });
        history.push({
          role: "tool",
          name: shared.active_tool_call.function.name,
          content: toolResult,
          tool_call_id: shared.active_tool_call.id
        });
        return {
          conversation_history: history,
          question: "Now, what is the next step?",
          _continue_conversation: true
        };
    next:
      default: join

  format_error_response:
    type: transform
    params:
      script: |
        var history = (shared.conversation_history || []).slice();
        var toolName = shared.active_tool_call ? shared.active_tool_call.function.name : "unknown_tool";
        var errorContent = "Tool " + toolName + " failed with status: " + input.status_code + ". Response: " + String(input.raw_body).substring(0, 500);
        history.push({
          role: "assistant",
          content: null,
          tool_calls: shared.llm_result.tool_calls
        });
        history.push({
          role: "tool",
          name: toolName,
          content: errorContent,
          tool_call_id: shared.active_tool_call.id
        });
        return {
          conversation_history: history,
          question: "The tool failed. Please try a different approach or inform the user.",
          _continue_conversation: true
        };
    next:
      default: join

  join:
    type: join
    next:
      default: llm

  format_final_response:
    type: transform
    params:
      script: |
        return {
          final_response: input.content || input.final_response || "Parallel tasks completed",
          conversation_history: shared.conversation_history || [],
          execution_summary: {
            completed_successfully: !input.error,
            conversation_turns: (shared.conversation_history || []).length,
            final_status: input.error ? "failed" : "completed",
            execution_type: "parallel"
          }
        };
    next:
      default: END